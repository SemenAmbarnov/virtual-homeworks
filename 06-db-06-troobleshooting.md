# Домашнее задание к занятию 6. «Troubleshooting»

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести эту операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя;
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.

Решение:

- Сначала необходимо найти запрос на который жалуется пользователь. Для этого использую команду:

db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 }})

Итогом будет выведенный ответ в котором будет содержаться PID процесса.

Далее удаляем его:

db.killOp(номер PID)

- Прочитал про несколько методов:
1. Использование параметра maxTimeMS() при запросах CRUD
2. Использования приведённой выше команды db.currentOp чтобы отслеживать медленные запросы
3. Или использовать настроенный профайлер для мониторинга медленных запросов. Для этого мы используем функцию db.setProfilingLevel() со значением 1 или 2. Значение 1 означает отслеживание медленных запросов, значение 2 отслеживание всех запросов и поэтому данное значение нежелательно, т.к будет влиять на производительность БД. Далее анализировать их с помощью explain и принять меры по их устранению в зависимости от результатов.


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:

- сначала происходит рост отношения записанных значений к истекшим,
- Redis блокирует операции записи.

Как вы думаете, в чём может быть проблема?


Решение: Интересная задача. В данном случае скорее всего по вводным данным идёт речь об истекающем объёме памяти, так называемым параметром maxmemory. 
А переполнилась она вероятнее всего из за проблем единомементного удаления ключей. Т.е говоря простым языком в БД скопилось очень много старых ключей которые должны единовременного удалиться, но ещё не сделали этого. После их удаления БД разгрузиться и работа нормализуется. И из за этого Redis блокирует операции записи. На redis.io данная проблема описывается как "задержка вызванная истечением срока действия" и для удаления используется 2 способа,т.к называемы lazy way и active way. В превом случае ключи удаляются по проверки истечения срока, но в таком случаем как раз может скопиться множество просроченных ключей. Во втором случае цикл истечения запускается каждые 100 миллисекунд и очищает истёкшие ключи. Надеюсь я правильно понял этот момент.

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

Решение:

В документации MySQL ошибке посвящена [статья](https://dev.mysql.com/doc/refman/8.0/en/gone-away.html), в ней перечислены множество причин данного ответа.
В данном случае наибольшая вероятность причины в том что был послан слишком большой запрос и в таком случае необходимо увеличить лимит запросов, изменив переменную сервера  max_allowed_packet которая по умолчанию имеет значение 64мб.

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?


Решение: 

Данная ошибка говорит о недостаточной памяти. В ряде статей ( не только с Percona ) предлагается увеличить файл подкачки находящийся здесь /proc/sys/vm/swappiness и увеличение физической памяти. Отключать Killer не рекомендуется, т.к это может сильно повлиять на работу сервиса, вплоть до его остановки.
Так же рекоммендуется изменить параметр vm_overcommit_memory в соответствии с параметрами текущего оборудования.
